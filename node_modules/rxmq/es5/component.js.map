{"version":3,"file":"component.js","sources":["../src/rx/endlessSubject.js","../src/rx/endlessReplaySubject.js","../src/utils/compareTopics.js","../src/utils/findTopicByName.js","../src/channel.js","../src/rxmq.js","../index.js"],"sourcesContent":["/* eslint no-param-reassign: [2, {\"props\": false}] */\nimport { Subject } from 'rxjs/Rx';\n\n/**\n * EndlessSubject extension of Rx.Subject.\n * This is pretty hacky, but so far I'd found no better way of having\n * Subjects that do no close on multicasted stream completion and on multiple errors.\n * For documentation refer to\n * [Rx.Subject docs](@link https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/subject.md).\n * The only difference is that EndlessSubject never triggers '.complete()' and\n * does not closes observers on errors (thus allowing to continuously dispatch them).\n */\nclass EndlessSubject extends Subject {\n  /**\n     * Dummy method override to prevent execution and Rx.Observable completion\n     * @return {void}\n     */\n  complete() {}\n\n  /**\n     * Override of error method that prevents stopping that Rx.Observer\n     * @param  {Error} error  - Error to be dispatched\n     * @return {void}\n     */\n  error(error) {\n    this.thrownError = error;\n    // dispatch to all observers\n    this.observers.forEach(os => {\n      // dispatch directly to destination\n      os.destination._error.call(os.destination._context, error);\n    });\n  }\n}\n\nexport {EndlessSubject};\n","/* eslint no-param-reassign: [2, {\"props\": false}] */\nimport { ReplaySubject } from 'rxjs/Rx';\n\n/**\n * EndlessReplaySubject extension of ReplaySubject.\n * This is pretty hacky, but so far I'd found no better way of having\n * Subjects that do no close on multicasted stream completion and on multiple errors.\n * For documentation refer to\n * [ReplaySubject docs](@link https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/replaysubject.md).\n * The only difference is that EndlessReplaySubject never triggers '.complete()' and\n * does not closes observers on errors (thus allowing to continuously dispatch them).\n */\nclass EndlessReplaySubject extends ReplaySubject {\n  /**\n     * Dummy method override to prevent execution and Observable completion\n     * @return {void}\n     */\n  complete() {}\n\n  /**\n     * Override of error method that prevents stopping that Observer\n     * @param  {Error} error  - Error to be dispatched\n     * @return {void}\n     */\n  error(error) {\n    // store error\n    this.error = error;\n    // dispatch to all observers\n    this.observers.forEach(os => {\n      // dispatch\n      os.error(error);\n      // mark observer as not stopped\n      os.isStopped = false;\n    });\n  }\n}\n\nexport {EndlessReplaySubject};\n","/**\n * Converts topic to search regex\n * @param  {String} topic   Topic name\n * @return {Regex}          Search regex\n * @private\n */\nconst topicToRegex = topic =>\n  `^${topic.split('.').reduce((result, segment, index, arr) => {\n    let res = '';\n    if (arr[index - 1]) {\n      res = arr[index - 1] !== '#' ? '\\\\.\\\\b' : '\\\\b';\n    }\n    if (segment === '#') {\n      res += '[\\\\s\\\\S]*';\n    } else if (segment === '*') {\n      res += '[^.]+';\n    } else {\n      res += segment;\n    }\n    return result + res;\n  }, '')}$`;\n\n/**\n * Compares given topic with existing topic\n * @param  {String}  topic         Topic name\n * @param  {String}  existingTopic Topic name to compare to\n * @return {Boolean}               Whether topic is included in existingTopic\n * @example\n * should(compareTopics('test.one.two', 'test.#')).equal(true);\n * @private\n */\nconst compareTopics = (topic, existingTopic) => {\n  // if no # or * found, do plain string matching\n  if (existingTopic.indexOf('#') === -1 && existingTopic.indexOf('*') === -1) {\n    return topic === existingTopic;\n  }\n  // otherwise do regex matching\n  const pattern = topicToRegex(existingTopic);\n  const rgx = new RegExp(pattern);\n  const result = rgx.test(topic);\n  return result;\n};\n\nexport {compareTopics};\n","/**\n * Find a specific subject by given name\n * @param  {Array}                  subjects    Array of subjects to search in\n * @param  {String}                 name        Name to search for\n * @return {(EndlessSubject|void)}              Found subject or void\n */\nconst findSubjectByName = (subjects, name) => {\n  const res = subjects.filter(s => s.name === name);\n  if (!res || res.length < 1) {\n    return undefined;\n  }\n\n  return res[0];\n};\n\nexport {findSubjectByName};\n","import { AsyncSubject, Observable } from 'rxjs/Rx';\nimport {EndlessSubject, EndlessReplaySubject} from './rx/index';\nimport {findSubjectByName, compareTopics} from './utils/index';\n\n/**\n * Rxmq channel class\n */\nclass Channel {\n  /**\n    * Represents a new Rxmq channel.\n    * Normally you wouldn't need to instantiate it directly, you'd just work with existing instance.\n    * @constructor\n    * @param  {Array}   plugins  Array of plugins for new channel\n    * @return {void}\n    */\n  constructor(plugins = []) {\n    /**\n         * Internal set of utilities\n         * @type {Object}\n         * @private\n         */\n    this.utils = {\n      findSubjectByName,\n      compareTopics,\n    };\n\n    /**\n         * Instances of subjects\n         * @type {Array}\n         * @private\n         */\n    this.subjects = [];\n    /**\n         * Channel bus\n         * @type {EndlessReplaySubject}\n         * @private\n         */\n    this.channelBus = new EndlessReplaySubject();\n    /**\n         * Permanent channel bus stream as Observable\n         * @type {Observable}\n         * @private\n         */\n    this.channelStream = this.channelBus.publish().refCount();\n\n    // inject plugins\n    plugins.map(this.registerPlugin.bind(this));\n  }\n\n  /**\n     * Returns EndlessSubject representing given topic\n     * @param  {String}         name           Topic name\n     * @return {EndlessSubject}             EndlessSubject representing given topic\n     * @example\n     * const channel = rxmq.channel('test');\n     * const subject = channel.subject('test.topic');\n     */\n  subject(name, {Subject = EndlessSubject} = {}) {\n    let s = this.utils.findSubjectByName(this.subjects, name);\n    if (!s) {\n      s = new Subject();\n      s.name = name;\n      this.subjects.push(s);\n      this.channelBus.next(s);\n    }\n    return s;\n  }\n\n  /**\n     * Get an Observable for specific set of topics\n     * @param  {String}         name        Topic name / pattern\n     * @return {Observable}                 Observable for given set of topics\n     * @example\n     * const channel = rxmq.channel('test');\n     * channel.observe('test.topic')\n     *        .subscribe((res) => { // default Observable subscription\n     *            // handle results\n     *        });\n     */\n  observe(name) {\n    // create new topic if it's plain text\n    if (name.indexOf('#') === -1 && name.indexOf('*') === -1) {\n      return this.subject(name);\n    }\n    // return stream\n    return this.channelStream.filter(obs => compareTopics(obs.name, name)).mergeAll();\n  }\n\n  /**\n     * Do a request that will be replied into returned AsyncSubject\n     * Alias for '.request()' that uses single object as params\n     * @param  {Object}  options                   Request options\n     * @param  {String}  options.topic             Topic name\n     * @param  {Any}     options.data              Request data\n     * @param  {Object}  options.DefaultSubject    Response subject, defaults to AsyncSubject\n     * @return {AsyncSubject}                      AsyncSubject that will dispatch the response\n     * @example\n     * const channel = rxmq.channel('test');\n     * channel.requestTo({\n     *     topic: 'test.topic',\n     *     data: 'test data',\n     * }).subscribe((response) => { // default Observable subscription\n     *     // handle response\n     * });\n     */\n  request({topic, data, Subject = AsyncSubject}) {\n    const subj = this.utils.findSubjectByName(this.subjects, topic);\n    if (!subj) {\n      return Observable.never();\n    }\n\n    // create reply subject\n    const replySubject = new Subject();\n    subj.next({replySubject, data});\n    return replySubject;\n  }\n\n  /**\n     * Channel plugin registration\n     * @param  {Object} plugin Plugin object to apply\n     * @return {void}\n     */\n  registerPlugin(plugin) {\n    for (const prop in plugin) {\n      if (!this.hasOwnProperty(prop)) {\n        /**\n                 * Hide from esdoc\n                 * @private\n                 */\n        this[prop] = plugin[prop];\n      }\n    }\n  }\n}\n\n/**\n * Channel definition\n */\nexport default Channel;\n","import Channel from './channel';\n\n/**\n * Rxmq message bus class\n */\nclass Rxmq {\n  /**\n    * Represents a new Rxmq message bus.\n    * Normally you'd just use a signleton returned by default, but it's also\n    * possible to create a new instance of Rxmq should you need it.\n    * @constructor\n    * @example\n    * import {Rxmq} from 'rxmq';\n    * const myRxmq = new Rxmq();\n    */\n  constructor() {\n    /**\n         * Holds channels definitions\n         * @type {Object}\n         * @private\n         */\n    this.channels = {};\n    /**\n         * Holds channel plugins definitions\n         * @type {Object}\n         * @private\n         */\n    this.channelPlugins = [];\n  }\n\n  /**\n     * Returns a channel for given name\n     * @param  {String} name  Channel name\n     * @return {Channel}      Channel object\n     * @example\n     * const testChannel = rxmq.channel('test');\n     */\n  channel(name = 'defaultRxmqChannel') {\n    if (!this.channels[name]) {\n      this.channels[name] = new Channel(this.channelPlugins);\n    }\n\n    return this.channels[name];\n  }\n\n  /**\n     * Register new Rxmq plugin\n     * @param  {Object} plugin      Plugin object\n     * @return {void}\n     * @example\n     * import myPlugin from 'my-plugin';\n     * rxmq.registerPlugin(myPlugin);\n     */\n  registerPlugin(plugin) {\n    for (const prop in plugin) {\n      if (!this.hasOwnProperty(prop)) {\n        /**\n                 * Hide from esdoc\n                 * @private\n                 */\n        this[prop] = plugin[prop];\n      }\n    }\n  }\n\n  /**\n     * Register new Channel plugin\n     * @param  {Object} plugin      Channel plugin object\n     * @return {void}\n     * @example\n     * import myChannelPlugin from 'my-channel-plugin';\n     * rxmq.registerChannelPlugin(myChannelPlugin);\n     */\n  registerChannelPlugin(plugin) {\n    this.channelPlugins.push(plugin);\n    for (const name in this.channels) {\n      if (this.channels.hasOwnProperty(name)) {\n        this.channels[name].registerPlugin(plugin);\n      }\n    }\n  }\n}\n\n/**\n * Rxmq bus definition\n */\nexport default Rxmq;\n","import RxMQ from './src/index';\n\nexport {EndlessSubject, EndlessReplaySubject, Channel} from './src/index';\nexport default new RxMQ();\n"],"names":["EndlessSubject","error","thrownError","observers","forEach","os","destination","_error","call","_context","Subject","EndlessReplaySubject","isStopped","ReplaySubject","topicToRegex","topic","split","reduce","result","segment","index","arr","res","compareTopics","existingTopic","indexOf","pattern","rgx","RegExp","test","findSubjectByName","subjects","name","filter","s","length","undefined","Channel","plugins","utils","channelBus","channelStream","publish","refCount","map","registerPlugin","bind","push","next","subject","obs","mergeAll","data","AsyncSubject","subj","Observable","never","replySubject","plugin","prop","hasOwnProperty","Rxmq","channels","channelPlugins","RxMQ"],"mappings":"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"}